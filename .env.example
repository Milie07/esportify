# =====================================================
# FICHIER DE CONFIGURATION - ENVIRONNEMENT
# =====================================================
#
# Ordre de chargement des fichiers .env (du moins prioritaire au plus prioritaire) :
#  1. .env                  → Valeurs par défaut (commitées)
#  2. .env.local            → Overrides locaux (NON commité, ignoré par Git)
#  3. .env.$APP_ENV         → Valeurs spécifiques à l'environnement (dev/prod/test)
#  4. .env.$APP_ENV.local   → Overrides spécifiques à l'environnement (NON commité)
#
# IMPORTANT : Les vraies variables d'environnement système ont priorité sur les fichiers .env
#
# ⚠️  NE JAMAIS définir de secrets de production dans des fichiers committés !
# Documentation : https://symfony.com/doc/current/configuration/secrets.html
#
# =====================================================
# DÉPLOIEMENT EN PRODUCTION
# =====================================================
#
# Option 1 : Fichier .env.local sur le serveur
# ---------------------------------------------
# 1. Copiez ce fichier : cp .env.example .env.local
# 2. Remplissez les vraies valeurs de production
# 3. NE JAMAIS committer .env.local (déjà dans .gitignore)
#
# Option 2 : Variables d'environnement Docker (RECOMMANDÉ)
# ---------------------------------------------------------
# Passez les variables directement au conteneur :
#
# docker run -d \
#   -e APP_ENV=prod \
#   -e APP_SECRET=$(openssl rand -hex 32) \
#   -e DATABASE_URL="mysql://user:pass@host:3306/db?serverVersion=8.0" \
#   -e MONGODB_URL="mongodb://user:pass@host:27017" \
#   -e CRON_SECRET_TOKEN=$(openssl rand -hex 32) \
#   -p 8080:8080 \
#   votre_image:tag
#
# Option 3 : Fichier .env sur le serveur avec docker-compose
# -----------------------------------------------------------
# Créez un fichier .env à côté de docker-compose.yml avec les vraies valeurs
# docker-compose les lira automatiquement
#
# =====================================================

###> symfony/framework-bundle ###
# Environnement d'exécution (dev, prod, test)
APP_ENV=dev

# Clé secrète de l'application
# ⚠️  ATTENTION : NE JAMAIS utiliser cette valeur en production !
#
# Pour développement local :
#   - Créez un fichier .env.local
#   - Générez une clé : openssl rand -hex 32
#   - Ajoutez : APP_SECRET=votre_clé_générée
#
# Pour production :
#   - Option A : Passez la variable au conteneur Docker : -e APP_SECRET=$(openssl rand -hex 32)
#   - Option B : Définissez-la dans .env.local sur le serveur (non commité)
#   - Option C : Utilisez les secrets Symfony : php bin/console secrets:set APP_SECRET
APP_SECRET=79cfd871db052e74b9031aeb703f5851
###< symfony/framework-bundle ###

###> doctrine/doctrine-bundle ###
# URL de connexion à la base de données
# Format : https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/configuration.html#connecting-using-a-url
#
# ⚠️  IMPORTANT : Vous DEVEZ configurer la version du serveur (serverVersion)
#
# Exemples de connexion :
#   SQLite     : "sqlite:///%kernel.project_dir%/var/data_%kernel.environment%.db"
#   MySQL      : "mysql://user:password@host:3306/dbname?serverVersion=8.0&charset=utf8mb4"
#   PostgreSQL : "postgresql://user:password@host:5432/dbname?serverVersion=16&charset=utf8"
#
# Pour développement local (Docker) :
#   Les valeurs ci-dessous fonctionnent avec docker-compose.yml
DATABASE_URL="mysql://esportify_user:esportify_pass@db:3306/esportify?serverVersion=8.0&charset=utf8mb4"

# Pour production :
#   Passez la variable au conteneur Docker avec vos vraies credentials :
#   -e DATABASE_URL="mysql://prod_user:prod_pass@prod_host:3306/prod_db?serverVersion=8.0"
#
# Si vous utilisez PostgreSQL en production :
#   -e DATABASE_URL="postgresql://prod_user:prod_pass@prod_host:5432/prod_db?serverVersion=16"

# URL de connexion à MongoDB (si utilisé)
# Format : mongodb://user:password@host:port/?authSource=admin
#
# Pour développement local (Docker) :
MONGODB_URL="mongodb://root:rootpass@mongo:27017/?authSource=admin"

# Pour production :
#   Passez la variable au conteneur Docker avec vos vraies credentials :
#   -e MONGODB_URL="mongodb://prod_user:prod_pass@prod_host:27017/?authSource=admin"
###< doctrine/doctrine-bundle ###

###> symfony/messenger ###
# Choose one of the transports below
# MESSENGER_TRANSPORT_DSN=amqp://guest:guest@localhost:5672/%2f/messages
# MESSENGER_TRANSPORT_DSN=redis://localhost:6379/messages
MESSENGER_TRANSPORT_DSN=doctrine://default?auto_setup=0
###< symfony/messenger ###

###> symfony/mailer ###
MAILER_DSN=null://null
###< symfony/mailer ###

###> cron/tournament-status ###
# Token secret pour la mise à jour automatique des statuts de tournois
# Utilisé pour appeler l'endpoint sécurisé : /admin/update-tournaments-status
#
# Ce token doit être identique dans :
#   1. Cette variable d'environnement sur le serveur
#   2. Les secrets GitHub Actions (si vous utilisez GitHub Actions)
#   3. Votre système de cron/scheduler qui appelle l'endpoint
#
# Pour développement local :
#   Valeur définie dans docker-compose.yml : "dev_secret_token_change_in_production"
#
# Pour production :
#   ⚠️  OBLIGATOIRE : Générez un token aléatoire sécurisé (32+ caractères)
#   Commande : openssl rand -hex 32
#   Passez la variable au conteneur : -e CRON_SECRET_TOKEN=$(openssl rand -hex 32)
#
# CRON_SECRET_TOKEN=your_secret_token_here
###< cron/tournament-status ###
